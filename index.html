<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Chess Visualization Tool</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        /* Style for the AR Scene container */
        #ar-scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
        }
        /* Style for the overlay UI */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to the AR scene */
            z-index: 10;
        }
        .control-panel {
            pointer-events: auto; /* Re-enable pointer events for the controls */
        }
        a-scene {
            position: absolute !important;
            width: 100%;
            height: 100%;
        }
    </style>
    
    <!-- A-Frame and AR.js Libraries -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <!-- We use the NFT version for flexibility, though we rely on a single pattern here -->
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.7/aframe/build/aframe-ar.min.js"></script>
</head>
<body class="bg-gray-50 overflow-hidden">

    <!-- UI Overlay for Instructions and Controls -->
    <div id="ui-overlay" class="p-4 flex flex-col items-center justify-start">
        <div class="control-panel bg-white/90 backdrop-blur-sm p-4 rounded-xl shadow-2xl w-full max-w-sm md:max-w-md">
            <h1 class="text-xl font-bold text-gray-800 mb-2">AR Chess Visualization MVP</h1>
            <p class="text-sm text-gray-600 mb-3">
                1. Point camera at the marker. 2. Input FEN & click Visualize.
            </p>
            
            <label for="fenInput" class="block text-xs font-medium text-gray-700">Current FEN Position:</label>
            <input type="text" id="fenInput" value="rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 1" 
                   class="w-full mt-1 p-2 border border-gray-300 rounded-lg text-sm focus:ring-blue-500 focus:border-blue-500"
                   placeholder="Enter FEN string (e.g., r3k2r/8/8/8/8/8/8/R3K2R w KQkq - 0 1)">
            
            <button id="visualizeBtn" 
                    class="mt-3 w-full py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-lg hover:bg-blue-700 transition duration-150">
                Visualize Position
            </button>

            <div class="mt-4 pt-2 border-t border-gray-200">
                <p class="text-xs font-semibold text-gray-800 mb-1">Marker Instructions:</p>
                <p class="text-xs text-red-600">
                    <span class="font-bold">Required:</span> Print a black square with a white border (the 'Hiro' marker) or use a plain black card to place on a flat surface. The virtual board will appear on this marker.
                </p>
            </div>
        </div>
    </div>
    
    <!-- A-Frame AR Scene -->
    <div id="ar-scene-container">
        <!-- Marker tracking using the standard 'hiro' pattern -->
        <a-scene embedded arjs='sourceType: webcam; detectionMode: mono; cameraParametersUrl: https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.7/data/camera_para.dat;'>
            
            <!-- This marker represents the physical chessboard placeholder -->
            <a-marker id="chess-marker" preset='hiro'>
                
                <!-- Virtual Chessboard (8x8 plane) - helps with alignment -->
                <a-plane id="board-base" rotation="-90 0 0" width="8" height="8" 
                         material="shader: flat; src: https://placehold.co/512x512/333333/ffffff?text=CHESSBOARD+MARKER"
                         position="0 0 -0.01"></a-plane>
                
                <!-- Piece Container: All pieces will be added here via JavaScript -->
                <a-entity id="piece-container"></a-entity>

            </a-marker>
            
            <!-- Camera (required for the AR scene) -->
            <a-entity camera></a-entity>

        </a-scene>
    </div>

    <script>
        const sceneEl = document.querySelector('a-scene');
        const pieceContainer = document.getElementById('piece-container');
        const fenInput = document.getElementById('fenInput');
        const visualizeBtn = document.getElementById('visualizeBtn');
        const boardBase = document.getElementById('board-base');

        // FEN mapping logic
        const FEN_PIECES = {
            'p': { type: 'Pawn', color: '#B91C1C', model: 'cylinder', radius: 0.3, height: 1.0 }, // Dark Red
            'P': { type: 'Pawn', color: '#FEF08A', model: 'cylinder', radius: 0.3, height: 1.0 }, // Light Yellow
            'r': { type: 'Rook', color: '#B91C1C', model: 'box', width: 0.6, height: 1.2, depth: 0.6 },
            'R': { type: 'Rook', color: '#FEF08A', model: 'box', width: 0.6, height: 1.2, depth: 0.6 },
            'n': { type: 'Knight', color: '#B91C1C', model: 'octahedron', radius: 0.7, detail: 1 },
            'N': { type: 'Knight', color: '#FEF08A', model: 'octahedron', radius: 0.7, detail: 1 },
            'b': { type: 'Bishop', color: '#B91C1C', model: 'cone', radius: 0.4, height: 1.5 },
            'B': { type: 'Bishop', color: '#FEF08A', model: 'cone', radius: 0.4, height: 1.5 },
            'q': { type: 'Queen', color: '#B91C1C', model: 'sphere', radius: 0.6 },
            'Q': { type: 'Queen', color: '#FEF08A', model: 'sphere', radius: 0.6 },
            'k': { type: 'King', color: '#B91C1C', model: 'box', width: 0.8, height: 2.0, depth: 0.8 },
            'K': { type: 'King', color: '#FEF08A', model: 'box', width: 0.8, height: 2.0, depth: 0.8 },
        };

        /**
         * Converts FEN piece notation to a 3D position relative to the marker center (0, 0, 0).
         * Assumes 1 unit = 1 square side. Board runs from X, Z = -4 to 4.
         * FEN ranks are 8 (j=0) down to 1 (j=7).
         * FEN files are A (i=0) to H (i=7).
         * @param {string} piece The piece character (P, k, r, etc.)
         * @param {number} fileIndex 0 (A) to 7 (H)
         * @param {number} rankIndex 0 (8) to 7 (1)
         * @returns {string} A-Frame position string "X Y Z"
         */
        function getPosition(piece, fileIndex, rankIndex) {
            // Calculate X (File): Center of the square
            // (i + 0.5) - 4 = i - 3.5
            const x = (fileIndex - 3.5); 
            
            // Calculate Z (Rank): Center of the square. FEN rank 0 (8) -> positive Z; rank 7 (1) -> negative Z
            // (7 - j + 0.5) - 4 = 3.5 - j - 0.5 = 3 - j. Let's use 3.5 - j for the center.
            const z = - (rankIndex - 3.5);

            // Calculate Y (Height): Half the piece height for correct base placement
            const pieceData = FEN_PIECES[piece];
            const y = pieceData.height ? (pieceData.height / 2) : 0.6; // Default height for sphere/octahedron

            // Add a small offset (0.01) to ensure the piece sits slightly above the plane (Z is up in A-Frame)
            return `${x.toFixed(2)} ${y.toFixed(2)} ${z.toFixed(2)}`;
        }

        /**
         * Parses the FEN string and generates A-Frame entities for the pieces.
         * @param {string} fen The FEN string (e.g., 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR')
         */
        function visualizeFen(fen) {
            // Clear existing pieces
            while (pieceContainer.firstChild) {
                pieceContainer.removeChild(pieceContainer.firstChild);
            }

            // Extract the board state part (before the space)
            const boardPart = fen.split(' ')[0];
            const ranks = boardPart.split('/');

            ranks.forEach((rank, rankIndex) => {
                let fileIndex = 0;
                for (let i = 0; i < rank.length; i++) {
                    const char = rank[i];
                    
                    if (/[1-8]/.test(char)) {
                        // Skip empty squares
                        fileIndex += parseInt(char, 10);
                    } else if (FEN_PIECES[char]) {
                        // Place a piece
                        const pieceData = FEN_PIECES[char];
                        const pieceEntity = document.createElement('a-entity');
                        
                        // Create the geometry entity (Pawn=Cylinder, King/Rook=Box, etc.)
                        const geometry = document.createElement(`a-${pieceData.model}`);
                        
                        // Set basic geometry attributes
                        geometry.setAttribute('color', pieceData.color);
                        geometry.setAttribute('material', 'shader: standard; metalness: 0.7; roughness: 0.3');
                        
                        // Set dimensions based on type
                        if (pieceData.model === 'cylinder' || pieceData.model === 'cone') {
                            geometry.setAttribute('radius', pieceData.radius);
                            geometry.setAttribute('height', pieceData.height);
                        } else if (pieceData.model === 'box') {
                            geometry.setAttribute('width', pieceData.width);
                            geometry.setAttribute('height', pieceData.height);
                            geometry.setAttribute('depth', pieceData.depth);
                        } else if (pieceData.model === 'sphere' || pieceData.model === 'octahedron') {
                            geometry.setAttribute('radius', pieceData.radius);
                        }

                        // Position the piece
                        const position = getPosition(char, fileIndex, rankIndex);
                        geometry.setAttribute('position', position);
                        
                        // Add piece to the container
                        pieceEntity.appendChild(geometry);
                        pieceContainer.appendChild(pieceEntity);
                        
                        fileIndex++;
                    }
                }
            });
            console.log(`Visualized FEN: ${fen}`);
        }

        // Event listener for the button
        visualizeBtn.addEventListener('click', () => {
            const fen = fenInput.value.trim();
            if (fen) {
                visualizeFen(fen);
            } else {
                console.error("Please enter a valid FEN string.");
            }
        });

        // Initialize visualization when the scene is loaded/ready
        sceneEl.addEventListener('loaded', () => {
            // Wait a moment for AR.js to initialize camera
            setTimeout(() => {
                visualizeFen(fenInput.value); // Load initial FEN
            }, 500);
        });

        // Add a visual cue to the board base to represent the files/ranks
        boardBase.addEventListener('loaded', () => {
            // Add a simple grid to the base plane for better visualization
            boardBase.setAttribute('material', {
                shader: 'standard',
                src: 'https://placehold.co/512x512/333333/ffffff?text=CHESSBOARD+MARKER', // Fallback texture
                repeat: '8 8'
            });
            
            // For a better look, let's create alternating planes (too complex for an MVP in a single file, so sticking to a textured placeholder)
            // The existing `src` on the plane is simple text, so let's add a visual white grid
            for(let i = 0; i < 8; i++) {
                for(let j = 0; j < 8; j++) {
                    if ((i + j) % 2 === 0) {
                        const square = document.createElement('a-plane');
                        square.setAttribute('width', 1);
                        square.setAttribute('height', 1);
                        square.setAttribute('color', '#A855F7'); // Purple for dark squares
                        square.setAttribute('position', `${(i - 3.5)} 0.001 ${-(j - 3.5)}`);
                        square.setAttribute('rotation', '-90 0 0');
                        boardBase.appendChild(square);
                    } else {
                        const square = document.createElement('a-plane');
                        square.setAttribute('width', 1);
                        square.setAttribute('height', 1);
                        square.setAttribute('color', '#FACC15'); // Yellow for light squares
                        square.setAttribute('position', `${(i - 3.5)} 0.001 ${-(j - 3.5)}`);
                        square.setAttribute('rotation', '-90 0 0');
                        boardBase.appendChild(square);
                    }
                }
            }
            // Remove the temporary texture placeholder
            boardBase.removeAttribute('material');
        });

    </script>
</body>
</html>
